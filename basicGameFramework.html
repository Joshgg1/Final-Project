<html>
<head>
	<!-- FINAL PROJECT JOSHUA GEORGE-->

	<style>
		canvas{
			background: #dddddd;
		}
	</style>

	<script>
		// Canvas context; used to call Canvas methods
		var c;

		// Canvas width and height.
		var cWidth, cHeight;

		// Stores the current keyboard state
		var curkeys = [];
		
		// Stores keys that have been newly pressed since last update
		var newkeys = [];

		// gamestate
		var gameState = "play";

		class smileClass
		{

		// Constructor
			constructor()
			{
				this.x = 325;
				this.y = 325;
				this.width = 75
				this.height = 75

				this.img = new Image();
				this.img.src = "smile.png";
				
			}

			// Movement methods - don't let bread move off the screen
			moveRight()
			{
				
				this.x += 10;
				
			}
			moveLeft(){
				
				this.x -= 5;
			
			}
			moveUp()
			{
				
				this.y -= 10;
				
			}
			moveDown()
			{
				
				this.y += 10;
				
			}

			// Draw method
			draw()
			{
				c.drawImage(this.img, this.x, this.y, this.width, this.height);
			}


		}
		class rectClass
		{

		// Constructor
			constructor(rectX, rectY)
			{
				this.x = rectX;
				this.y = rectY;
				this.width = 100
				this.height = 100

				this.img = new Image();
				this.img.src = "rectangle.png";
				
			}
			wrap()
			{
				//
				// ADD YOUR MOVEMENT CODE HERE
				//
				this.x -= 5

				//
				// ADD YOUR WRAP LOGIC HERE
				//
				if(this.x < -100)
                {
                    this.x = +900
                }


             
			 }

			//add movement code here

			// Draw method
			draw()
			{
				c.drawImage(this.img, this.x, this.y, this.width, this.height);
			}


		}
		class starClass
		{

		// Constructor
			constructor(starX, starY)
			{
				this.x = starX;
				this.y = starY;
				this.width = 80
				this.height = 80

				this.img = new Image();
				this.img.src = "star.png";
				
			}
			wrap()
			{
				//
				// ADD YOUR MOVEMENT CODE HERE
				//
				this.x -= 5

				//
				// ADD YOUR WRAP LOGIC HERE
				//
				if(this.x < -100)
                {
                    this.x = +900
                }


             
			 }

			//add movement code here

			// Draw method
			draw()
			{
				c.drawImage(this.img, this.x, this.y, this.width, this.height);
			}


		}

		var rectArray = [];
		var starArray = [];

		// Initializes entire game framework. This method should only be called
		// once, by the body onload event handler.
		function gameFrameworkInit(){		
			// Initialize key arrays
			for (i = 0; i < 256; i++){
				curkeys[i] = false;
				newkeys[i] = false;
			}
		
			// Initialize global variables for canvas
			c = myCanvas.getContext('2d');
			cWidth = myCanvas.width;
			cHeight = myCanvas.height;

			smile = new smileClass();
			rect = new rectClass();
			
			// star = new starClass();

			for (i = 0; i < 16; i++){
				rectArray[i] = new rectClass(1450*i, 20);
			}

			for (i = 0; i < 16; i++){
				starArray[i] = new starClass(2400*i, 20);
			}




			// Start listeners for getting keyboard state
	        window.addEventListener('keydown',
	        						 function(e){
										if (!curkeys[e.keyCode]){
											curkeys[e.keyCode] = true;
											newkeys[e.keyCode] = true;
										}
									 }
	        					   );
	        
	        window.addEventListener('keyup',
	        						 function(e){ curkeys[e.keyCode] = false; }
	        					   );

			// Schedule the update function to be called right before the next repaint.
			// (At the end of the update function, it will schedule itself to be called
			// again before the NEXT repaint, and so on.
			window.requestAnimationFrame(gameUpdate);
		}




		function gameUpdate(){
			// curkeys movement
			if(gameState = "play")
			{
				if(curkeys[39])
				{
					smile.moveRight()
				}
				if(curkeys[40])
				{
					smile.moveDown()
				}
				if(curkeys[38])
				{
					smile.moveUp()
				}
				
				if(newkeys[32])
				{
					gameState = "pause";
					console.log(gameState)
				}
				
				smile.moveLeft()
			
		
			
				rect.wrap()
			
			
			

			
			
			
			// DO NOT ADD OR MODIFY ANY CODE BELOW HERE


			// Reset newkeys
			for (i = 0; i < 256; i++){
				newkeys[i] = false;
			}

			// At the end of the update function, repaint the screen
			gameDraw();
				
			// Last thing the update function does is to schedule itself to be called
			// again before the next repaint
			window.requestAnimationFrame(gameUpdate);
			}
		}


		function gameDraw(){
			// Clear the canvas before we draw the current frame
			c.clearRect(0,0,cWidth,cHeight);


			//draw
			smile.draw()
			
			if(gameState = "play")
			{
				for (i = 0; i < 16; i++)
				{
					rectArray[i].draw();
					rectArray[i].wrap();
					if(rectArray[i].x < -99)
					{
						rectArray[i].y = Math.floor(Math.random() * (600))
						
					}
					
					
					
				}
				for (i = 0; i < 16; i++)
				{
					starArray[i].draw();
					starArray[i].wrap();
					if(starArray[i].x < -99)
					{
						starArray[i].y = Math.floor(Math.random() * (600))
						
					}

				}
			}
			

			
		}


	</script>

</head>


<body onload="gameFrameworkInit()">
	
	<canvas id="myCanvas" width="800" height="600" style="background: url('background.webp')"></canvas>

</body>


</html>
